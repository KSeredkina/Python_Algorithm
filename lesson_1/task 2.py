# 2. Выполнить логические побитовые операции «И», «ИЛИ» и др. над числами 5 и 6. Выполнить над числом 5 побитовый
# сдвиг вправо и влево на два знака. Объяснить полученный результат.

number_1 = 5
number_2 = 6

# "И" оператор. Возвращает 1, когда оба бита оказываются равными 1, иначе он возвращает 0.
binary_and = number_1 & number_2

# "ИЛИ" оператор. Возвращают 1, когда любой из битов оказывается равным 1, иначе он возвращает 0.
binary_or = number_1 | number_2

# Побитовое отрицание. Возвращает число заменяя все 1 на 0 и наоборот у исходного числа.
binary_not_number_1 = ~number_1
binary_not_number_2 = ~number_2

# "Исключительное ИЛИ". Возвращает истину, если один из битов равен 1, а другой бит равен 0, в противном
# случае он возвращает ложь.
binary_xor = number_1 ^ number_2

# Побитовый сдвиг вправо. Сдвигает биты числа вправо и в результате заполняет 0 на пустом месте / пустоте. Это дает
# эффект, подобный делению числа в некоторой степени двойки.
binary_right_shift = number_2 >> 2

# Побитовый сдвиг влево. Сдвигает биты числа влево и заполняет 0 на пустых / пустых местах, оставшихся в результате.
# Это дает эффект, аналогичный умножению числа на некоторую степень двойки.
binary_left_shift = number_2 << 2

print(f'Бинарный вид чисел {bin(number_1)} ({number_1}), {bin(number_2)} ({number_2})')
print(f'Побитовое «И» (AND): {bin(binary_and)} ({binary_and})')
print(f'Побитовое «ИЛИ» (OR): {bin(binary_or)} ({binary_or})')
print(f'Побитовое отрицание (NOT): {bin(binary_not_number_1)} ({binary_not_number_1}),{bin(binary_not_number_2)} '
      f'({binary_not_number_2})')
print(f'Исключающее «ИЛИ» (XOR): {bin(binary_xor)} ({binary_xor})')
print(f'Битовый сдвиг вправо: {bin(binary_right_shift)} ({binary_right_shift})')
print(f'Битовый сдвиг влево: {bin(binary_left_shift)} ({binary_left_shift})')
